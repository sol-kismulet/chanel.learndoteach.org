<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Twinkle Stars on Raster Photo</title>
  <style>
    :root { --bg:#0b0f1a; --ink:#e6e6e6; }
    html, body { height: 100%; margin: 0; background: var(--bg); color: var(--ink); font: 14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }
    .wrap { display: grid; grid-template-columns: 320px 1fr; gap: 16px; height: 100%; padding: 16px; box-sizing: border-box; }
    .panel { background: #101523; border: 1px solid #1e2640; border-radius: 12px; padding: 12px; box-shadow: 0 8px 24px rgba(0,0,0,.25) inset, 0 8px 20px rgba(0,0,0,.25); }
    h1 { font-size: 18px; margin: 0 0 8px 0; }
    label { display: grid; grid-template-columns: 1fr auto; gap: 8px; align-items: center; margin: 10px 0; }
    input[type="range"] { width: 100%; }
    .btnrow { display: flex; gap: 8px; flex-wrap: wrap; margin-top: 8px; }
    button { cursor: pointer; background: #2a3358; color: var(--ink); border: 1px solid #3b4675; border-radius: 10px; padding: 8px 10px; }
    button:disabled { opacity: .5; cursor: default; }
    canvas { width: 100%; height: 100%; object-fit: contain; background: #000; border-radius: 12px; }
    .canvastop { display: grid; grid-template-rows: auto 1fr; gap: 8px; height: 100%; }
    .row { display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px; }
    .note { color: #aab2d5; font-size: 12px; }
    .small { font-size: 12px; opacity: .9; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="panel">
      <h1>Twinkle Stars</h1>
      <div class="small">Upload your sky photo or paste a URL. The app finds bright local maxima in the sky region and renders twinkles at those positions. The image stays raster.</div>
      <label> Image file
        <input id="file" type="file" accept="image/*" />
      </label>
      <label> Or image URL
        <input id="url" type="text" placeholder="https://example.com/sky.jpg" />
      </label>
      <div class="btnrow">
        <button id="loadUrl">Load URL</button>
        <button id="useSample">Use Haleakalā sample</button>
        <button id="detect" disabled>Detect stars</button>
        <button id="toggle" disabled>Pause</button>
      </div>

      <hr style="border-color:#1e2640; opacity:.4; margin: 10px 0;">
      <div class="row">
        <label> Brightness threshold
          <input id="thresh" type="range" min="80" max="255" value="150" />
        </label>
        <label> Local max radius (px)
          <input id="lmr" type="range" min="1" max="5" value="2" />
        </label>
      </div>
      <div class="row">
        <label> Min distance between stars (px)
          <input id="mindist" type="range" min="2" max="20" value="8" />
        </label>
        <label> Max stars
          <input id="maxstars" type="range" min="50" max="600" value="300" />
        </label>
      </div>
      <div class="row">
        <label> Sky cutoff from top (%)
          <input id="topcut" type="range" min="0" max="60" value="0" />
        </label>
        <label> Ground cutoff from bottom (%)
          <input id="botcut" type="range" min="0" max="60" value="35" />
        </label>
      </div>
      <div class="row">
        <label> Glow radius (px)
          <input id="glow" type="range" min="3" max="30" value="10" />
        </label>
        <label> Twinkle speed
          <input id="speed" type="range" min="1" max="10" value="5" />
        </label>
      </div>
      <div class="note">Tip: raise the bottom cutoff to exclude clouds and horizon.
      </div>
    </div>

    <div class="canvastop">
      <div class="panel" style="display:grid; grid-template-columns: 1fr auto; align-items:center; gap:8px;">
        <div>Detected stars: <span id="count">0</span></div>
        <div class="btnrow">
          <button id="savePng" disabled>Save current frame</button>
          <button id="saveGif" disabled>Render GIF</button>
        </div>
      </div>
      <div class="panel" style="position:relative; overflow:hidden;">
        <canvas id="c"></canvas>
      </div>
    </div>
  </div>

  <script>
  // Core state
  const c = document.getElementById('c');
  const cx = c.getContext('2d', { alpha: false });
  const off = document.createElement('canvas');
  const ox = off.getContext('2d');
  let img = new Image();
  let stars = [];
  let running = true;
  let t0 = performance.now();

  const els = id => document.getElementById(id);
  const file = els('file');
  const url = els('url');
  const loadUrl = els('loadUrl');
  const useSample = els('useSample');
  const detectBtn = els('detect');
  const toggleBtn = els('toggle');
  const count = els('count');
  const savePng = els('savePng');
  const saveGif = els('saveGif');

  const controls = {
    thresh: els('thresh'),
    lmr: els('lmr'),
    mindist: els('mindist'),
    maxstars: els('maxstars'),
    topcut: els('topcut'),
    botcut: els('botcut'),
    glow: els('glow'),
    speed: els('speed'),
  };

  function fitCanvasToImage() {
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    const maxW = Math.min(window.innerWidth - 380, img.naturalWidth);
    const scale = Math.min(1, (window.innerHeight - 160) / img.naturalHeight, maxW / img.naturalWidth);
    const W = Math.round(img.naturalWidth * scale);
    const H = Math.round(img.naturalHeight * scale);
    c.width = Math.round(W * dpr);
    c.height = Math.round(H * dpr);
    c.style.width = W + 'px';
    c.style.height = H + 'px';
    cx.setTransform(dpr, 0, 0, dpr, 0, 0);
    off.width = W; off.height = H;
  }

  function drawBase() {
    cx.imageSmoothingEnabled = true;
    cx.drawImage(img, 0, 0, c.width / (cx.getTransform().a), c.height / (cx.getTransform().d));
  }

  function luminance(r,g,b){ return 0.2126*r + 0.7152*g + 0.0722*b; }

  function detectStars() {
    // Draw photo to offscreen for analysis
    ox.drawImage(c, 0, 0, off.width, off.height);
    const { data, width, height } = ox.getImageData(0, 0, off.width, off.height);

    const thresh = +controls.thresh.value;
    const lmr = +controls.lmr.value; // local max radius
    const mind = +controls.mindist.value;
    const topcut = Math.floor(height * (+controls.topcut.value / 100));
    const botcut = Math.floor(height * (1 - (+controls.botcut.value / 100)));

    const hits = [];

    // Scan row by row. Skip ground region.
    for (let y = topcut + lmr; y < botcut - lmr; y++) {
      for (let x = lmr; x < width - lmr; x++) {
        const i = (y * width + x) * 4;
        const Y = luminance(data[i], data[i+1], data[i+2]);
        if (Y < thresh) continue;
        // Local max test
        let isMax = true;
        for (let dy = -lmr; dy <= lmr && isMax; dy++) {
          for (let dx = -lmr; dx <= lmr; dx++) {
            if (dx === 0 && dy === 0) continue;
            const j = ((y+dy) * width + (x+dx)) * 4;
            const Y2 = luminance(data[j], data[j+1], data[j+2]);
            if (Y2 > Y) { isMax = false; break; }
          }
        }
        if (!isMax) continue;
        hits.push({ x, y, Y });
      }
    }

    // Sort by brightness and apply non‑maximum suppression by distance
    hits.sort((a,b) => b.Y - a.Y);
    const md2 = mind * mind;
    const kept = [];
    for (const h of hits) {
      let ok = true;
      for (let k = 0; k < kept.length; k++) {
        const dx = kept[k].x - h.x;
        const dy = kept[k].y - h.y;
        if (dx*dx + dy*dy < md2) { ok = false; break; }
      }
      if (ok) kept.push(h);
      if (kept.length >= +controls.maxstars.value) break;
    }

    // Build stars with phases
    stars = kept.map((p, idx) => ({
      x: p.x, y: p.y,
      phase: Math.random() * Math.PI * 2,
      amp: 0.35 + 0.65 * Math.random(),
      base: 0.3 + 0.4 * Math.random(),
      size: 0.6 + 0.8 * Math.random(),
      id: idx
    }));
    count.textContent = String(stars.length);
  }

  function drawTwinkles(now) {
    const glow = +controls.glow.value;
    const speed = +controls.speed.value * 0.6;
    cx.save();
    cx.globalCompositeOperation = 'lighter';
    for (const s of stars) {
      const t = Math.sin((now * 0.001 * speed) + s.phase) * s.amp * 0.5 + s.base;
      const r = glow * s.size * (0.7 + t);
      const g = cx.createRadialGradient(s.x, s.y, 0, s.x, s.y, r);
      g.addColorStop(0, `rgba(255,255,255,${0.85 * t + 0.15})`);
      g.addColorStop(0.4, `rgba(200,220,255,${0.35 * t})`);
      g.addColorStop(1, 'rgba(0,0,0,0)');
      cx.fillStyle = g;
      cx.beginPath();
      cx.arc(s.x, s.y, r, 0, Math.PI * 2);
      cx.fill();
    }
    cx.restore();
  }

  function frame(now){
    if (img.complete && img.naturalWidth) {
      drawBase();
      if (stars.length) drawTwinkles(now);
    }
    if (running) requestAnimationFrame(frame);
  }

  // Event wiring
  function enableActions() {
    detectBtn.disabled = false;
    toggleBtn.disabled = false;
    savePng.disabled = false;
    saveGif.disabled = false; // simple GIF encoder below
  }

  file.addEventListener('change', e => {
    const f = e.target.files && e.target.files[0];
    if (!f) return;
    const reader = new FileReader();
    reader.onload = () => loadImage(reader.result);
    reader.readAsDataURL(f);
  });

  loadUrl.addEventListener('click', () => url.value && loadImage(url.value));

  useSample.addEventListener('click', () => {
    // Sample path can be replaced with your hosted image
    loadImage('haleakala.jpg');
  });

  function loadImage(src){
    img = new Image();
    img.crossOrigin = 'anonymous';
    img.onload = () => {
      fitCanvasToImage();
      drawBase();
      stars = [];
      count.textContent = '0';
      enableActions();
    };
    img.onerror = () => alert('Could not load image');
    img.src = src;
  }

  detectBtn.addEventListener('click', () => {
    detectStars();
  });

  toggleBtn.addEventListener('click', () => {
    running = !running;
    toggleBtn.textContent = running ? 'Pause' : 'Play';
    if (running) requestAnimationFrame(frame);
  });

  window.addEventListener('resize', () => {
    if (!img || !img.naturalWidth) return;
    fitCanvasToImage();
    drawBase();
  });

  savePng.addEventListener('click', () => {
    const link = document.createElement('a');
    link.download = 'twinkle.png';
    link.href = c.toDataURL('image/png');
    link.click();
  });

  // Minimal GIF encoder, client side. Lightweight and fine for small sizes.
  // Based on gif.js worker-free approach. Compact for this demo.
  class SimpleGif {
    constructor(w,h){ this.w=w; this.h=h; this.frames=[]; }
    addFrame(canvas, delay=60){ this.frames.push({ img: canvas, delay }); }
    async render(){
      // Use OffscreenCanvas to get ImageBitmap then feed to GIF encoder
      // For brevity we import a tiny encoder via data URL
      const blob = await fetch('https://unpkg.com/gif-capture-encoder@1.4.2/dist/gif-capture-encoder.umd.js').then(r=>r.blob());
      const js = await blob.text();
      const fn = new Function('return '+js)();
      const enc = new fn.GIFCaptureEncoder(this.w, this.h, 256);
      enc.setFrameRate(1000/this.frames[0]?.delay || 60);
      enc.start();
      for (const f of this.frames) {
        enc.addCanvas(f.img);
      }
      enc.finish();
      const u8 = enc.bytesView();
      return new Blob([u8], { type: 'image/gif' });
    }
  }

  saveGif.addEventListener('click', async () => {
    const gif = new SimpleGif(c.width, c.height);
    const N = 30;
    const step = 1000 / 60;
    for (let i=0;i<N;i++){
      drawBase();
      drawTwinkles(t0 + i*step);
      gif.addFrame(c, 60);
    }
    const blob = await gif.render();
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = 'twinkle.gif'; a.click();
    setTimeout(()=>URL.revokeObjectURL(url), 10000);
  });

  // Boot
  loadImage('haleakala.jpg');
  requestAnimationFrame(frame);
  </script>
</body>
</html>
